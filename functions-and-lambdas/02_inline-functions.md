使用高阶函数需要付出运行时的代价：每个函数都是一个对象，并且拥有一个闭包（函数体内可访问的那些变量）。内存分配（函数对象和类）以及虚调用（virtual call）都会带来运行时开销。

但是，貌似很多情况下，内联 lambda 表达式可以消除这类开销。下面的函数很好低展示了这种情况。`lock` 函数可以内联到调用处。考虑如下 case：

```kotlin
lock(l) { foo() }
```

